[{
    "title": "MySQL 配置和基本 CRUD",
    "date": "",
    "description": "",
    "body": "MySQL  配置   配置环境 安装成功后，并不能马上就能在命令行终端使用 mysql 命令链接数据库。因为，安装路径还没有添加到系统搜索路径(环境变量)下输入mysql -u root -p会出现：zsh: command not found: mysql的提示。此时需要配置环境变量。\n 1. bashshell的解决方法： `sudo vim .bash_profile` `export PATH=${PATH}:/usr/local/mysql/bin` 然后esc退出insert状态，并在最下方输入:wq保存退出。 `source .bash_profile` 2. zshshell的解决方法： `sudo vim ~/.zshrc`，在这里面添加： `export PATH=${PATH}:/usr/local/mysql/bin` 保存后 `source ~/.zshrc` `mysql -u root -p`    修改初始密码 设置别名或添加环境变量后，就可以正常使用 mysql 命令连接数据库了。但是初次登陆会要求修改初始登陆密码。方法如下：\n使用初始密码登陆(三种方法)：\n 1. mysql -u root -p 2. mysql -h ip -u root 3. mysql --host= 127.0.0.1 --user=root --password=root 修改密码（将 [your new password] 替换成自己的新密码）：\nALTER USER 'root'@'localhost' IDENTIFIED BY '[your new password]';   改变字符集\n 查看当前默认字符集 mysql\u0026gt; show variables like '%char%'; 如果都是latin1，需改成utf-8，以防止除拉丁文以外的数据乱码。 因为“从5.7.18开始不在二进制包中提供my-default.cnf文件”来自于官网https://dev.mysql.com/doc/refman/5.7/en/binary-installation.html 所以需要自己创建。 先关闭MySQL服务 打开终端输入 cd /etc sudo vim my.cnf 用于在etc中创建my.cnf文件 拷贝以下配置文件进去\n# Example MySQL config file for medium systems. # # This is for a system with little memory (32M - 64M) where MySQL plays # an important part, or systems up to 128M where MySQL is used together with # other programs (such as a web server) # # MySQL programs look for option files in a set of # locations which depend on the deployment platform. # You can copy this option file to one of those # locations. For information about these locations, see: # http://dev.mysql.com/doc/mysql/en/option-files.html # # In this file, you can use all long options that a program supports. # If you want to know which options a program supports, run the program # with the \u0026quot;--help\u0026quot; option. # The following options will be passed to all MySQL clients [client] default-character-set=utf8 #password = your_password port = 3306 socket = /tmp/mysql.sock # Here follows entries for some specific programs # The MySQL server [mysqld] character-set-server=utf8 init_connect='SET NAMES utf8 port = 3306 socket = /tmp/mysql.sock skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M character-set-server=utf8 init_connect='SET NAMES utf8' # Don't listen on a TCP/IP port at all. This can be a security enhancement, # if all processes that need to connect to mysqld run on the same host. # All interaction with mysqld must be made via Unix sockets or named pipes. # Note that using this option without enabling named pipes on Windows # (via the \u0026quot;enable-named-pipe\u0026quot; option) will render mysqld useless! # #skip-networking # Replication Master Server (default) # binary logging is required for replication log-bin=mysql-bin # binary logging format - mixed recommended binlog_format=mixed # required unique id between 1 and 2^32 - 1 # defaults to 1 if master-host is not set # but will not function as a master if omitted server-id = 1 # Replication Slave (comment out master section to use this) # # To configure this host as a replication slave, you can choose between # two methods : # # 1) Use the CHANGE MASTER TO command (fully described in our manual) - # the syntax is: # # CHANGE MASTER TO MASTER_HOST=\u0026lt;host\u0026gt;, MASTER_PORT=\u0026lt;port\u0026gt;, # MASTER_USER=\u0026lt;user\u0026gt;, MASTER_PASSWORD=\u0026lt;password\u0026gt; ; # # where you replace \u0026lt;host\u0026gt;, \u0026lt;user\u0026gt;, \u0026lt;password\u0026gt; by quoted strings and # \u0026lt;port\u0026gt; by the master's port number (3306 by default). # # Example: # # CHANGE MASTER TO MASTER_HOST='125.564.12.1', MASTER_PORT=3306, # MASTER_USER='joe', MASTER_PASSWORD='secret'; # # OR # # 2) Set the variables below. However, in case you choose this method, then # start replication for the first time (even unsuccessfully, for example # if you mistyped the password in master-password and the slave fails to # connect), the slave will create a master.info file, and any later # change in this file to the variables' values below will be ignored and # overridden by the content of the master.info file, unless you shutdown # the slave server, delete master.info and restart the slaver server. # For that reason, you may want to leave the lines below untouched # (commented) and instead use CHANGE MASTER TO (see above) # # required unique id between 2 and 2^32 - 1 # (and different from the master) # defaults to 2 if master-host is set # but will not function as a slave if omitted #server-id = 2 # # The replication master for this slave - required #master-host = \u0026lt;hostname\u0026gt; # # The username the slave will use for authentication when connecting # to the master - required #master-user = \u0026lt;username\u0026gt; # # The password the slave will authenticate with when connecting to # the master - required #master-password = \u0026lt;password\u0026gt; # # The port the master is listening on. # optional - defaults to 3306 #master-port = \u0026lt;port\u0026gt; # # binary logging - not required for slaves, but recommended #log-bin=mysql-bin # Uncomment the following if you are using InnoDB tables #innodb_data_home_dir = /usr/local/mysql/data #innodb_data_file_path = ibdata1:10M:autoextend #innodb_log_group_home_dir = /usr/local/mysql/data # You can set .._buffer_pool_size up to 50 - 80 % # of RAM but beware of setting memory usage too high #innodb_buffer_pool_size = 16M #innodb_additional_mem_pool_size = 2M # Set .._log_file_size to 25 % of buffer pool size #innodb_log_file_size = 5M #innodb_log_buffer_size = 8M #innodb_flush_log_at_trx_commit = 1 #innodb_lock_wait_timeout = 50 [mysqldump] quick max_allowed_packet = 16M [mysql] no-auto-rehash # Remove the next comment character if you are not familiar with SQL #safe-updates default-character-set=utf8 [myisamchk] key_buffer_size = 20M sort_buffer_size = 20M read_buffer = 2M write_buffer = 2M [mysqlhotcopy] interactive-timeout 保存退出\n 打开MySQL服务 输入mysql\u0026gt; show variables like '%char%'; 结果如下 +--------------------------+-----------------------------------------------------------+ | Variable_name | Value | +--------------------------+-----------------------------------------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/local/mysql-5.7.21-macos10.13-x86_64/share/charsets/ | +--------------------------+-----------------------------------------------------------+ 8 rows in set (0.00 sec) 都变成了utf - 8 测试新建的database是不是utf-8  mysql\u0026gt; create database db1; mysql\u0026gt; show create databases db1; +\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | Database | Create Database | +\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | db1 | CREATE DATABASE db1 /*!40100 DEFAULT CHARACTER SET utf8 */ | +\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+        基本CRUD语句\n DDL（data definition language） DML（data manipulation language） DCL（Data Control Language）  操作数据库：  (Create) 创建  创建数据库：  create database 数据库名称；   创建数据库，判断是否存在，再创建：  create database if not exists 数据库名称;   创建数据库， 并且指定字符集  create database character set 字符集名;     (Retrieve) 查询  查询所有数据库名称  show databases;   查询某个数据库的字符集  show create database 数据库名称；     (Update) 修改  修改数据库的字符集  alter database 数据库名称 character set 字符集名称；     (Delete) 删除  删除数据库  drop database 数据库名称     使用数据库  查询当前正在使用的数据库名称  select database();   使用数据库  use 数据库名称；      操作表：  (Create) 创建  语法：  create table 表名( 列名1 数据类型1, 列名2 数据类型1, \u0026hellip; 列名n 数据类型n ); 数据类型：  int  age int,   double  score double(5,2)   date  只包含年月日，yyyy-MM-dd   datetime  包含年月日时分秒，yyyy-MM-dd HH:mm:ss   datestamp  包含年月日时分秒，yyyy-MM-dd HH:mm:ss 如果没有赋值，这默认使用当前时间   varchar  name varchar(20):姓名最多20个字符     复制表  create table 表名 like 被复制的表名；       (Retrieve) 查询  查询表  show tables;   查询表结构  desc 表名;     (Update) 修改  修改表名  alter table 表名 rename to 新表名   修改表的字符集  alter table 表名 character set 字符集名称   添加1列  alter table 表名 add 列名 数据类型；   修改列名称 类型  alter table 表名 change 列名 新列名 新数据类型 alter table 表名 modify 列名 新数据类型；   删除列  alter table 表名 drop 列名；     (Delete) 删除  drop table 表名 drop table if exist 表名        ",
    "ref": "/post/blog7/"
  },{
    "title": "Multithreading -- Thread and Runnable(Deutsch/中文)",
    "date": "",
    "description": "",
    "body": "Multithreading \u0026ndash;\u0026gt; Thread and Runnable(Deutsch/中文) （Deutsch）Der Unterschied und die Verwendung von Thread und Runnable Weil es in einigen Büchern und Tutorials so beschrieben wird: Runnable ist einfacher, die gemeinsame Nutzung von Ressourcen zwischen mehreren Threads zu realisieren, Thread kann dies jedoch nicht! Dies ist jedoch nicht der Fall, es gibt fast keinen wesentlichen Unterschied zwischen den beiden.\nDie Unterschiede:  Runnable wird durch Implementierung seiner Interface implementiert Thread wird implementiert, indem seine Klasse geerbt wird Die ausführbare Interface unterstützt die Mehrfachvererbung Thread implementiert die Runnable-Interface und wurde erweitert. Das Thread implementiert Runnable , sodass Runnable und Thread selbst *** nicht vergleichbar *** sind. -Der folgende Thread-Quellcode erklärt:  public class Thread implements Runnable { /* Make sure registerNatives is the first thing \u0026lt;clinit\u0026gt; does. */ private static native void registerNatives(); static { registerNatives(); } private volatile String name; private int priority; /* Whether or not the thread is a daemon thread. */ private boolean daemon = false; /* Interrupt state of the thread - read/written directly by JVM */ Verwendung  Thread:  Erstellen Sie eine Klasse, die Thread erbt @Override run () -Methode Erstellen Sie eine Instanz dieser Klasse in der Testklasse Verwenden Sie die start () -Methode direkt für dieses Objekt, das die run () -Methode tatsächlich ausführt. Dies ist jedoch nur ein einziger Thread für Mitgliedsvariablen (Ressourcen), wenn Sie Ressourcen gemeinsam nutzen möchten. Sie müssen das Instanzobjekt als Parameter in die Thread-Konstruktionsmethode einfügen, um den Parameter zu übergeben und ein echtes Multithreading zu erzielen.    public class Ticket extends Thread{ private int ticket = 100; @Override public void run() { while (true) { if (ticket \u0026gt; 0) { System.out.println(Thread.currentThread().getName() + \u0026quot;numberSellingTicketNumber:\u0026quot; + ticket ); ticket--; } else break; } } } public class ThreadSafeDemo { public static void main(String[] args) { Ticket t = new Ticket(); t.start(); } } Viele Tutorials und Bücher werden wie oben beschrieben, dies ist jedoch nur ein einziger Thread für Mitgliedsvariablen (Ressourcen). Wenn Sie Ressourcen(den Code) nutzen möchten\nprivates int Ticket = 100; Sie müssen den Objekt nur als Parameter an das folgende Thread-Konstruktionsmethode übergeben, um ein echtes Multithreading zu erzielen.\nTicket t1 = new Ticket(); Thread th1 = new Thread(t1,\u0026quot;thread1\u0026quot;); Thread th2 = new Thread(t1,\u0026quot;thread2\u0026quot;); th1.start() th2.start() Da die Thread-Klasse vererbt wird, handelt es sich immer noch um eine Einzelvererbung, und eine Mehrfachvererbung kann nicht realisiert werden. Zur Optimierung können Sie die zweite Methode verwenden: Interface implementieren Runnable, um die Vererbung mehrerer Interface zu implementieren.\n Runnable\n Erstellen Sie eine Klasse zum Implementieren der Runnable-Klasse (diese Klasse ist tatsächlich dieselbe wie die Thread-Klasse, beide sind Implementierungsklassen von Runnable, sodass Sie später direkt die Thread-Konstruktionsmethode Thread (Runnable r) verwenden können @Override run () -Methode Erstellen Sie gerade eine Objekt der Klasse in der Testklasse Verwenden Sie die Thread-Konstruktionsmethode, um das Instanzobjekt zu übergeben Verwenden Sie die Start()methode    public class SynchronizedLock implements Runnable { private int ticket = 100; //Object obj = new Object(); @Override public void run() { while (true) { synchronized (this) { if (ticket \u0026gt; 0) { System.out.println(Thread.currentThread().getName() + \u0026quot;numberSellingTicketNumber:\u0026quot; + ticket ); ticket--; } else break; } } } }  public class ThreadSynchronized { public static void main(String[] args) { SynchronizedLock syn = new SynchronizedLock(); Thread syn1 = new Thread(syn); Thread syn2 = new Thread(syn); Thread syn3 = new Thread(syn); syn1.start(); syn2.start(); syn3.start(); } }  (中文)Thread 和 Runnable的区别和用法 因为在某些书上和教程中是这样描述的：Runnable更容易可以实现多个线程间的资源共享，而Thread不可以！但事实上并不是如此，两者没有本质区别。\n区别：  Runnable的实现方式是实现其接口即可 Thread的实现方式是继承其类 Runnable接口支持多继承 Thread实现了Runnable接口并进行了扩展，而Thread和Runnable的实质是实现的关系，不是同类东西，所以Runnable或Thread本身 没有可比性。  以下Thread的源代码解释了：Thread和Runnable的实质是实现的关系     public class Thread implements Runnable { /* Make sure registerNatives is the first thing \u0026lt;clinit\u0026gt; does. */ private static native void registerNatives(); static { registerNatives(); } private volatile String name; private int priority; /* Whether or not the thread is a daemon thread. */ private boolean daemon = false; /* Interrupt state of the thread - read/written directly by JVM */ 用法  Thread:  创建一个类继承Thread @Override run()方法 在测试类中创建这个类的实例对象 对这个对象直接使用start()方法，实际上是执行了run()方法， 但是这样只是对成员变量（资源）设置了单线程，如果想资源共享， 需要把实例对象作为参数放入 Thread构造方法中传参，以实现真正的多线程。    public class Ticket extends Thread{ private int ticket = 100; @Override public void run() { while (true) { if (ticket \u0026gt; 0) { System.out.println(Thread.currentThread().getName() + \u0026quot;号窗口在卖第\u0026quot; + ticket + \u0026quot;张票\u0026quot;); ticket--; } else break; } } } public class ThreadSafeDemo { public static void main(String[] args) { Ticket t = new Ticket();//只创建了一个实现类对象 t.start(); //直接调用start()方法，实际上是调用了run()方法 } } 许多教程和书上都是像上面这样这样描述的，但这只是对成员变量（资源）设置了单线程，如果想资源共享,也就是代码中的\nprivate int ticket = 100; ，只需要向如下把实例对象作为参数放入 Thread 构造方法 中传参，以实现真正的多线程。\nTicket t1 = new Ticket(); Thread th1 = new Thread(t1,\u0026quot;thread1\u0026quot;); Thread th2 = new Thread(t1,\u0026quot;thread2\u0026quot;); th1.start() th2.start() 由于用的是继承Thread类，导致还是单继承，无法实现多继承。 为了优化，可以用第二种发方法：实现interface Runnable 来实现多接口继承 2. Runnable 1. 创建一个类实现Runnable类(这个类实际上和Thread类一样，两者都是Runnable的实现类，所以后面可以直接使用Thread的构造方法Thread(Runnable r) 2. @Override run()方法 3. 在测试类中创建刚刚的类的实例对象 4. 使用Thread构造方法，将实例对象传入 5. 使用start方法\npublic class SynchronizedLock implements Runnable { private int ticket = 100; //Object obj = new Object(); @Override public void run() { while (true) { //以下是访问了 共享数据 的代码 //用同步代码块的方式同步代码，不出现重复和错误！！ synchronized (this) { if (ticket \u0026gt; 0) { System.out.println(Thread.currentThread().getName() + \u0026quot;号窗口在卖第\u0026quot; + ticket + \u0026quot;张票\u0026quot;); ticket--; } else break; } } } }  public class ThreadSynchronized { public static void main(String[] args) { SynchronizedLock syn = new SynchronizedLock(); Thread syn1 = new Thread(syn); Thread syn2 = new Thread(syn); Thread syn3 = new Thread(syn); syn1.start(); syn2.start(); syn3.start(); } } ",
    "ref": "/post/blog6/"
  },{
    "title": "SSH verbinden(Deutsch/中文 )",
    "date": "",
    "description": "",
    "body": "SSH verbinden (Deutsch/中文 )   Wenn eine Remote-Anmeldung zulässig ist, können Sie sich mit Secure Shell (SSH) oder SecureCRT, Transmit von einem anderen Computer bei Ihrem Mac anmelden.\n  Sie können Telnet nicht verwenden, um sich bei Ihrem Mac anzumelden.\n   Richten Sie die Remote-Anmeldung auf dem Mac ein - Vorbereitung: ob SSH schon aktiviert ist？\nErkennungsbefehl: sudo systemsetup -getremotelogin Aktivieren Sie den Befehl: sudo systemsetup -setremotelogin on Schalten Sie den Befehl aus: sudo systemsetup -setremotelogin off Überprüfen Sie, ob ssh aktiviert ist Wenn Sie Vollzugriffsberechtigungen benötigen, gehen Sie zu \u0026ldquo;Sicherheit\u0026rdquo; -\u0026gt; \u0026ldquo;Datenschutz\u0026rdquo; sshd und Terminal einklicken\n- Durchführen  Wählen Sie auf Ihrem Mac Apple-Menü\u0026gt; Systemeinstellungen, klicken Sie auf Freigabe und wählen Sie dann Remote-Anmeldung. Aktivieren Sie das Kontrollkästchen \u0026ldquo;Remote Login\u0026rdquo;. Wenn \u0026ldquo;Remote Login\u0026rdquo; ausgewählt ist, ist auch der SFTP-Dienst (Secure FTP) aktiviert. Geben Sie an, welche Benutzer sich anmelden können: -Alle Benutzer: Jeder Benutzer Ihres Computers und jeder im Netzwerk kann sich anmelden. -Nur diese Benutzer: Klicken Sie auf die Schaltfläche Hinzufügen und wählen Sie aus, wer sich remote anmelden kann. \u0026ldquo;Benutzer und Gruppen\u0026rdquo; umfasst alle Benutzer auf Ihrem Mac. \u0026ldquo;Netzwerkbenutzer\u0026rdquo; und \u0026ldquo;Netzwerkgruppen\u0026rdquo; umfassen alle Personen in Ihrem Netzwerk.   Melden Sie sich von einem anderen Computer an  Öffnen Sie auf einem anderen Computer die App \u0026ldquo;Terminal\u0026rdquo; (falls es sich um einen Mac handelt) oder den SSH-Client. Geben Sie den Befehl ssh ein und drücken Sie die Eingabetaste. -Das allgemeine Format des Befehls ssh: ssh Benutzername @ IPAddress  Wenn Ihr Benutzername beispielsweise steve lautet und die IP-Adresse Ihres Computers 10.1.2.3 lautet, geben Sie den folgenden Befehl ein: $ ssh steve@10.1.2.3   Geben Sie das Passwort ein und drücken Sie die Eingabetaste.  SecureSRT Transmit zur Terminalsteuerung und Dateiübertragung\n SSH 连接  如果允许远程登录，您可以从另一台电脑使用 Secure Shell (SSH) 或SecureCRT,Transmit 登录您的 Mac。  不能使用Telnet来登录您的 Mac。 在Mac上设置远程登录 准备： Mac 操作系统检测SSH是否开启\n检测命令：sudo systemsetup -getremotelogin 开启命令：sudo systemsetup -setremotelogin on 关闭命令：sudo systemsetup -setremotelogin off 看是否开启了ssh 若需要全盘进入权限，进入“安全”\u0026ndash;\u0026gt; \u0026ldquo;数据保护“设置 ，需开启sshd,和terminal\n执行  在 Mac 上，选取苹果菜单 \u0026gt;“系统偏好设置”，点按“共享”，然后选择“远程登录”。 选择“远程登录”复选框。选择“远程登录”时，还会启用安全 FTP（SFTP）服务。 指定哪些用户可以登录：  所有用户：您电脑的任何用户及网络上的任何人都可以登录。 仅这些用户：点按添加按钮 ，然后选取谁能以远程方式登录。“用户与群组”包含您 Mac 上的所有用户。“网络用户”和“网络群组”包含您网络上的所有人。     从其他电脑登录 Mac  在其他电脑上，打开“终端” App（如果是 Mac）或 SSH 客户端。 键入 ssh 命令，然后按下 Return 键。  ssh 命令的通用格式：ssh username@IPAddress 例如，如果您的用户名为 steve，您电脑的 IP 地址为 10.1.2.3，请输入以下命令：$ ssh steve@10.1.2.3   输入密码，然后按下 Return 键。  SecureSRT Transmit 实现终端控制和文件传输\n",
    "ref": "/post/blog5/"
  },{
    "title": "Linux experimental environment in multi-node （Deutsch/ 中文）",
    "date": "",
    "description": "",
    "body": "Linux experimental environment in multi-node（Deutsch/ 中文）  Beim ifconfig kontrolieren die IP-Adresse des Hosts und Linux Pingen Sie die Adressen beider Parteien an, um festzustellen, ob sie kommunizieren können Netzwerkeinstellungen der virtuellen Maschine wlan Legen Sie die statische IP für die virtuelle Maschine fest  su root, um Root-Rechte einzugeben dhclient legt zu diesem Zeitpunkt eine verfügbare IP-Adresse ein statistische IP statt dynamische IP fest. Um sicherzustellen, dass sie sich nicht ändert, muss sie auf der Netzwerkkarte konfiguriert werden vim / etc / sysconfig / network- scripts / ifcfg-ens33 bootproto = ~~ dhcp ~~ static onboot = ~~ no ~~ yes Add static ip-\u0026gt;  IPADDR = 192.168.40.128 NETMASK = 255.255.255.0 GATEWAY = 192.168.178.1 DNS1 = 119,29,29,29 -: wp speichern und beenden   Starten Sie die Netzwerkkarte systemctl neu. systemctl restart network.service    Werkzeuge  SecureCRT-Verbindungstest Dateiübertragung übertragen  linux 实验环境及其网络配置  ifconfig 看宿主机和linux的ip地址 ping 双方地址看是否可通 虚拟机网络设置 wlan 给虚拟机设置静态ip  su root 进入root 权限 dhclient 设置一个网络类可用ip地址,此时为动态ip，为了保证不变化，需要配置到网卡 vim /etc/sysconfig/network- scripts/ifcfg-ens33 bootproto = dhcp static onboot = no yes 添加静态ip-\u0026gt; IPADDR = 192.168.40.128  NETMASK=255.255.255.0 GATEWAY=192.168.178.1 DNS1=119.29.29.29 :wp保存退出   重启网卡 systemctl restart network.service    工具  SecureCRT 连接测试 transmit 文件互传  ",
    "ref": "/post/blog4/"
  },{
    "title": "Contact_me",
    "date": "",
    "description": "",
    "body": "Email：dingsiyu0107@gmail.com ",
    "ref": "/contact/"
  },{
    "title": "Class",
    "date": "",
    "description": "",
    "body": "",
    "ref": "/categories/"
  },{
    "title": "About_me",
    "date": "",
    "description": "",
    "body": "Hi ！ it\u0026rsquo;s me Ding Nice to see you！ i\u0026rsquo;m studying in Leibniz University Hannover Germany . major mechanical. Love coding just like you. If you got any question about my blogs , just contact me in (Chinese;Deutsch;English) : dingsiyu0107@gmail.com ",
    "ref": "/about/"
  },{
    "title": "Hugo Website erstellen",
    "date": "",
    "description": "",
    "body": "Hugo Website erstellen(Verbereitungsphase) 1）Notwendige Werkzeuge  homebrew （Es ist ein Softwaresverwaltungstool unter Mac OS, mit dem Sie problemlos Softwaretools usw. installieren / deinstallieren können, ähnlich wie Softwaresverwaltungstools wie apt-get unter Linux und npm von node） hugo （Hugo ist ein statischer Website-Generator, der von der Sprache Go geschieben wird. Einfach, benutzerfreundlich, effizient, leicht zu erweitern und schnell bereitzustellen.） git （Versionskontrolle）  2)Installationsmethode homebrew：  eingeben im Terminal /usr/bin/ruby -e \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install Automatisch installiert würden  hogo  brew install hugo  git：  brew install git   Hugo Wesite erstellen(Prozess)   hugo new site myblog Site generieren \u0026ldquo;myblog\u0026rdquo; ersetzbar\n  Öffnen Sie die Sitetheme.gohugo.io um themes zu finden\n  cd myblog in path\n  Zum Beispiel：git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c Laden Sie das m10c-Thema in das \u0026ldquo;Themen\u0026rdquo; Ordner herunter\n  hugo server -t m10c --buildDrafts Starten Sie den lokale Server Suchen Sie die localhost-Adresse im Terminal. Sie können überprüfen, ob die lokale Webseite erfolgreich geöffnet wurde\n  Doku schreiben：hugo new post/blog.md Erstellen Sie das erste Markdown-Dokument(Markdown_form empfehlen)\n  Erstellen Sie ein Repository auf dem Remote-Github\n  hugo --theme=m10c --baseUrl=\u0026quot;http://XXXXXXX.github.io/\u0026quot; --buildDrafts Generieren Sie automatisch die Dateien, wenn diese mit Remotesadressen verknüpft sind\n  cd public/ git init //Initialisieren Sie den \u0026quot;public\u0026quot; Ordner, um daraus ein Git-Paket zu machen git add . git commit -m\u0026quot;my hugo first blog\u0026quot; git remote add origin http://github.com/xxxxxxx/xxxxxxx.github.io.git git push -u origin master //first time -Seite aktualisieren\ncd myblog hugo cd public git add . git status git commit -m \u0026quot;add blog post\u0026quot; git push noch etwas Problem? Kannst du es nicht schaffen? Kontakt Email ： dingsiyu0107@gmail.com\n",
    "ref": "/post/blog3/"
  },{
    "title": "Markdown",
    "date": "",
    "description": "",
    "body": "markdown 基本 1）标题  在想要设置为标题的文字前面加#来表示 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。  注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。\n示例：\n# 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题  2)字体   加粗\n要加粗的文字左右分别用两个*号包起来\n  斜体\n要倾斜的文字左右分别用一个*号包起来，尾部加`\n  斜体加粗\n要倾斜和加粗的文字左右分别用三个*号包起来\n  删除线\n要加删除线的文字左右分别用两个~~号包起来\n  示例：\n**这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 效果如下：\n 这是加粗的文字 这是倾斜的文字` 这是斜体加粗的文字 这是加删除线的文字   3) 引用 在引用的文字前加\u0026gt;即可。引用也可以嵌套，如加两个\u0026raquo;三个\u0026raquo;\u0026gt; n个\u0026hellip;\n示例：\n\u0026gt; 引用 \u0026gt;\u0026gt; 引用 效果如下：\n 引用\n 引用\n   4）分割线 三个或者三个以上的 -\n示例：\n--- ------- 效果如下：   5) 图片 语法：\n![图片下方解释](图片地址“图片title”) 示例： 利用ms图床\n 6) 超链接  [链接名](链接地址) 示例：\ngoogle\n 7) 列表 无序列表\n- liebiao + liebiao * liebiao 示例：\n liebiao   liebiao   liebiao  多用 -\n有序列表\n1. liebiao 2. liebiao 示例：\n liebiao liebiao  列表嵌套 上下级之间敲三个空格\n 8）表格 语法\n 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 示例：\n   姓名 专业 年龄     小丁 mb 18   小成 bwl 18   小张 economic 18   小刘 et 18   大蒋 et 18     9）代码 语法 打点 daima\ndaima  嘿嘿嘿 没了\n",
    "ref": "/post/blog2/"
  },{
    "title": "hugo 静态网页创建",
    "date": "",
    "description": "",
    "body": "hugo 静态网页创建(准备) 1）hugo 必要的工具  homebrew （是一款Mac OS上的软件包管理工具，通过它可以很方便的安装/卸载软件工具等，类似于Linux下的apt-get，node的npm等包管理工具） hugo （Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。） git （版本控制）  2)安装方法 homebrew：  terminal输入 /usr/bin/ruby -e \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install 自动完成安装  hogo 利用braw：  brew install hugo  git：  brew install git   hugo 网页创建   hugo new site myblog生成站点 myblog 可替换\n  打开网页theme.gohugo.io找主题\n  cd myblog进入path\n  例如：git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c在themes目录下下载m10c主题\n  hugo server -t m10c --buildDrafts本地启动服务器 在terminal中找到localhost地址，可检查网页是否本地成功打开\n  写文档：hugo new post/blog.md创建第一个markdown文档\n  在远端github 创建repository\n  hugo --theme=m10c --baseUrl=\u0026quot;http://XXXXXXX.github.io/\u0026quot; --buildDrafts 关联远端地址自动生成public文件\n   cd public/ git init //初始化public文件夹使之成为git包 git add . git commit -m\u0026quot;my hugo first blog\u0026quot; git remote add origin http://github.com/xxxxxxx/xxxxxxx.github.io.git git push -u origin master //first time  -更新页面\ncd myblog hugo cd public git add . git status git commit -m \u0026quot;add blog post\u0026quot; git push 有问题？ 搞不成？ 问我！ Email ： dingsiyu0107@gmail.com\n",
    "ref": "/post/blog1/"
  }]
